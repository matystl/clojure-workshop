;; Analyzed by ClojureScript 0.0-3211
{:use-macros nil, :excludes #{}, :name re-frame.handlers, :imports nil, :requires {re-frame.utils re-frame.utils, re-frame.db re-frame.db}, :uses {app-db re-frame.db, warn re-frame.utils, first-in-vector re-frame.utils, error re-frame.utils}, :defs {handle {:protocol-inline nil, :meta {:arglists (quote ([event-v])), :doc "Given an event vector, look up the handler, then call it.\n  By default, handlers are not assumed to be pure. They are called with\n  two paramters:\n    - the `app-db` atom\n    - the event vector\n  The handler is assumed to side-effect on `app-db` - the return value is ignored.\n  To write a pure handler, use the \"pure\" middleware when registering the handler.", :end-column 13, :end-line 80, :column 7, :line 80, :file "/home/maty/vacuumlabs/clojurescript/example/resources/public/js/compiled/out/re_frame/handlers.cljs"}, :name re-frame.handlers/handle, :variadic false, :file "resources/public/js/compiled/out/re_frame/handlers.cljs", :end-column 13, :method-params ([event-v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 80, :end-line 80, :max-fixed-arity 1, :fn-var true, :arglists (quote ([event-v])), :doc "Given an event vector, look up the handler, then call it.\n  By default, handlers are not assumed to be pure. They are called with\n  two paramters:\n    - the `app-db` atom\n    - the event vector\n  The handler is assumed to side-effect on `app-db` - the return value is ignored.\n  To write a pure handler, use the \"pure\" middleware when registering the handler.", :test true}, *handling* {:meta {:dynamic true, :end-column 26, :end-line 77, :column 16, :line 77, :file "/home/maty/vacuumlabs/clojurescript/example/resources/public/js/compiled/out/re_frame/handlers.cljs"}, :file "resources/public/js/compiled/out/re_frame/handlers.cljs", :line 77, :column 1, :end-line 77, :end-column 26, :dynamic true, :test true, :name re-frame.handlers/*handling*}, register-base {:protocol-inline nil, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([event-id handler-fn] [event-id middleware handler-fn]), :arglists ([event-id handler-fn] [event-id middleware handler-fn]), :arglists-meta (nil nil)}, :arglists (quote ([event-id handler-fn] [event-id middleware handler-fn])), :doc "register a handler for an event.\n  This is low level and it is expected that \"re-frame.core/register-handler\" would\n  generally be used.", :end-column 20, :end-line 58, :column 7, :line 58, :file "/home/maty/vacuumlabs/clojurescript/example/resources/public/js/compiled/out/re_frame/handlers.cljs"}, :name re-frame.handlers/register-base, :variadic false, :file "resources/public/js/compiled/out/re_frame/handlers.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([event-id handler-fn] [event-id middleware handler-fn]), :arglists ([event-id handler-fn] [event-id middleware handler-fn]), :arglists-meta (nil nil)}, :method-params ([event-id handler-fn] [event-id middleware handler-fn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 58, :end-line 58, :max-fixed-arity 3, :fn-var true, :arglists ([event-id handler-fn] [event-id middleware handler-fn]), :doc "register a handler for an event.\n  This is low level and it is expected that \"re-frame.core/register-handler\" would\n  generally be used.", :test true}, clear-handlers! {:protocol-inline nil, :meta {:arglists (quote ([])), :doc "Unregister all event handlers", :end-column 22, :end-line 52, :column 7, :line 52, :file "/home/maty/vacuumlabs/clojurescript/example/resources/public/js/compiled/out/re_frame/handlers.cljs"}, :name re-frame.handlers/clear-handlers!, :variadic false, :file "resources/public/js/compiled/out/re_frame/handlers.cljs", :end-column 22, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 52, :end-line 52, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Unregister all event handlers", :test true}, lookup-handler {:protocol-inline nil, :meta {:arglists (quote ([event-id])), :end-column 21, :end-line 47, :column 7, :line 47, :file "/home/maty/vacuumlabs/clojurescript/example/resources/public/js/compiled/out/re_frame/handlers.cljs"}, :name re-frame.handlers/lookup-handler, :variadic false, :file "resources/public/js/compiled/out/re_frame/handlers.cljs", :end-column 21, :method-params ([event-id]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 47, :end-line 47, :max-fixed-arity 1, :fn-var true, :arglists (quote ([event-id])), :test true}, id->fn {:meta {:private true, :end-column 22, :end-line 44, :column 16, :line 44, :file "/home/maty/vacuumlabs/clojurescript/example/resources/public/js/compiled/out/re_frame/handlers.cljs"}, :file "resources/public/js/compiled/out/re_frame/handlers.cljs", :line 44, :column 1, :end-line 44, :end-column 22, :private true, :test true, :name re-frame.handlers/id->fn}, comp-middleware {:protocol-inline nil, :meta {:arglists (quote ([v])), :doc "Given a vector of middleware, filter out any nils, and use \"comp\" to compose the elements.\n  v can have nested vectors, and will be flattened before \"comp\" is applied.\n  For convienience, if v is a function (assumed to be middleware already), just return it.\n  Filtering out nils allows us to create Middleware conditionally like this:\n     (comp-middleware [pure (when debug? debug)])  ;; that 'when' might leave a nil\n  ", :end-column 22, :end-line 22, :column 7, :line 22, :file "/home/maty/vacuumlabs/clojurescript/example/resources/public/js/compiled/out/re_frame/handlers.cljs"}, :name re-frame.handlers/comp-middleware, :variadic false, :file "resources/public/js/compiled/out/re_frame/handlers.cljs", :end-column 22, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 22, :end-line 22, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Given a vector of middleware, filter out any nils, and use \"comp\" to compose the elements.\n  v can have nested vectors, and will be flattened before \"comp\" is applied.\n  For convienience, if v is a function (assumed to be middleware already), just return it.\n  Filtering out nils allows us to create Middleware conditionally like this:\n     (comp-middleware [pure (when debug? debug)])  ;; that 'when' might leave a nil\n  ", :test true}, report-middleware-factories {:protocol-inline nil, :meta {:arglists (quote ([v])), :doc "See https://github.com/Day8/re-frame/issues/65", :end-column 34, :end-line 9, :column 7, :line 9, :file "/home/maty/vacuumlabs/clojurescript/example/resources/public/js/compiled/out/re_frame/handlers.cljs"}, :name re-frame.handlers/report-middleware-factories, :variadic false, :file "resources/public/js/compiled/out/re_frame/handlers.cljs", :end-column 34, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9, :end-line 9, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "See https://github.com/Day8/re-frame/issues/65", :test true}}, :require-macros nil, :cljs.analyzer/constants {:order [:re-frame-factory-name :else], :seen #{:re-frame-factory-name :else}}, :doc nil}